---
description: Rules for Next.js + Supabase full-stack application development
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.json"]
alwaysApply: true
---
# Tech Stack & Architecture

## Primary Stack
- **Frontend**: Next.js with App Router, TypeScript, Tailwind CSS
- **Backend**: Supabase (PostgreSQL, Auth, Storage, Realtime, Edge Functions)
- **API Layer**: tRPC for end-to-end type safety and API development
- **Deployment**: Vercel (frontend) + Supabase (backend)
- **Validation**: Zod for schema validation
- **Payments**: Stripe integration
- **Email**: Resend for transactional emails
- **Monitoring**: Sentry for error tracking

# Development Guidelines

## Code Style & Standards
- Use TypeScript with strict mode enabled
- Prefer functional components with hooks over class components
- Use server components by default, client components only when necessary
- Follow Next.js App Router conventions for file structure
- Use kebab-case for file and folder names
- Use PascalCase for component names
- Use camelCase for functions and variables

## Next.js Specific
- Leverage App Router features (layouts, loading, error boundaries)
- Use Server Actions for form submissions and mutations
- Implement proper metadata for SEO
- Use dynamic imports for code splitting when appropriate
- Prefer `next/image` over regular `<img>` tags
- Use `next/link` for client-side navigation

## Tailwind CSS
- Use Tailwind utility classes over custom CSS
- Organize classes logically: layout → spacing → colors → typography → effects
- Use responsive design prefixes appropriately (sm:, md:, lg:, xl:)
- Leverage Tailwind's design system for consistency
- Use custom CSS classes only when Tailwind utilities are insufficient

## Supabase Integration
- Use Supabase client-side SDK for browser interactions
- Use Supabase server-side SDK for API routes and server components
- Implement proper Row Level Security (RLS) policies
- Use typed queries with generated types from Supabase CLI
- Handle auth state properly with middleware and route guards
- Use Supabase Storage for file uploads with proper security policies

## tRPC Integration
- Use tRPC for all API endpoints to ensure end-to-end type safety
- Define procedures in server/api/trpc.ts following tRPC conventions
- Use Zod schemas for input validation in tRPC procedures
- Implement proper error handling with tRPC error types
- Use tRPC React Query hooks for data fetching in components
- Organize routers by feature (auth, users, companies, etc.)
- Leverage tRPC middleware for authentication and logging
- Use server-side tRPC client for server components when needed

## Data Management
- Use Zod schemas for all data validation
- Define TypeScript interfaces that match Supabase table schemas
- Implement proper error handling for database operations
- Use optimistic updates where appropriate
- Cache data efficiently with React Query or SWR if needed

## Authentication
- Use Supabase Auth for user management
- Implement proper session handling
- Create protected routes with middleware
- Handle auth state changes properly in components
- Use server-side auth checks for sensitive operations

## API Design
- Use Next.js API routes sparingly, prefer Server Actions
- Implement proper error handling and status codes
- Validate all inputs with Zod schemas
- Use TypeScript for API route parameters and responses
- Implement rate limiting where necessary

## Error Handling & Monitoring
- Integrate Sentry for error tracking and performance monitoring
- Use proper error boundaries in React components
- Implement graceful fallbacks for failed operations
- Log meaningful error messages for debugging
- Use try-catch blocks for async operations

## Performance & Optimization
- Implement proper loading states and skeletons
- Use React Suspense for data fetching
- Optimize images with Next.js Image component
- Implement proper caching strategies
- Monitor Core Web Vitals
- Use dynamic imports for heavy components

## Security Best Practices
- Validate all user inputs with Zod
- Implement proper CORS policies
- Use environment variables for sensitive data
- Follow Supabase security best practices
- Implement proper CSP headers
- Sanitize user-generated content

## Testing (when applicable)
- Write unit tests for utility functions
- Test API routes with proper mocking
- Use React Testing Library for component tests
- Test authentication flows thoroughly
- Mock Supabase client in tests

## File Organization
```
src/
├── app/                 # Next.js App Router pages
├── components/          # Reusable React components
├── lib/                # Utility functions and configurations
├── hooks/              # Custom React hooks
├── types/              # TypeScript type definitions
├── schemas/            # Zod validation schemas
├── utils/              # Helper functions
└── styles/             # Global styles and Tailwind config
```

## Environment Variables
- Use `.env.local` for development secrets
- Document all required environment variables
- Use Vercel environment variables for production
- Never commit sensitive data to version control

## Code Quality
- Use ESLint and Prettier for code formatting
- Implement proper TypeScript types, avoid `any`
- Write meaningful commit messages
- Use meaningful variable and function names
- Comment complex logic appropriately
- Keep functions small and focused