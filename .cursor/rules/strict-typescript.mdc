---
title: Strict TypeScript Rules
description: Enforce strict typing and eliminate all TypeScript warnings/errors
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: true
---

# Strict TypeScript Rules

## Core Principles
1. **Zero TypeScript errors**: Never ignore or bypass TypeScript errors
2. **Strong typing**: Always use explicit types, avoid `any`
3. **No unused variables**: Remove or properly handle all unused variables
4. **Proper type safety**: Use proper type guards and assertions

## Specific Rules

### Type Safety
- Never use `any` type - always specify proper types
- Use type guards for runtime type checking
- Prefer interfaces over types for object shapes
- Use generics for reusable type-safe code

### Variable Usage
- Remove all unused variables and imports
- Use underscore prefix (`_variable`) for parameters that must exist but aren't used
- Use `Omit` or `Pick` utility types to properly handle interface subsets

### Error Handling
- Always handle TypeScript errors properly - never use `@ts-ignore`
- Fix compilation errors by improving type definitions
- Use proper type assertions only when absolutely necessary

### Interface Design
```typescript
// Good: Explicit, well-typed interfaces
interface UpdateMetrics {
  mrr: number
  growth: number
  users: number
  retention: number
}

interface Update {
  id: string
  type: 'major' | 'minor' | 'coolsies'
  content: string
  metrics?: UpdateMetrics
  createdAt: Date
}

// Bad: Using any or loose typing
interface Update {
  metrics?: Record<string, any>  // Never use any
}
```

### Function Signatures
```typescript
// Good: Proper parameter handling
function process({ user, onLogout }: Omit<Props, 'profile'>) {
  // Implementation
}

// Good: Unused parameters properly marked
function handler({ ctx: _ctx }) {  // If ctx must exist but isn't used
  // Implementation
}

// Better: Remove unused parameters entirely
function handler() {
  // Implementation
}
```

### Type Guards
```typescript
// Good: Proper type checking
function isUpdateMetrics(obj: unknown): obj is UpdateMetrics {
  return typeof obj === 'object' && 
         obj !== null && 
         'mrr' in obj && 
         typeof (obj as any).mrr === 'number'
}

// Usage with type guard
if (update.metrics && isUpdateMetrics(update.metrics)) {
  const mrrInThousands = update.metrics.mrr / 1000
}
```

## Enforcement
- All TypeScript errors must be fixed before committing
- Use `npm run type-check` to verify type safety
- Configure ESLint rules for strict TypeScript:
  - `@typescript-eslint/no-explicit-any`: error
  - `@typescript-eslint/no-unused-vars`: error
  - `@typescript-eslint/strict-boolean-expressions`: error

## Examples to Avoid
```typescript
// ❌ Bad
const data: any = response.data
const result = data.someProperty  // Type unsafe

// ❌ Bad
function component({ profile, ...props }) {  // Unused profile
  return <div {...props} />
}

// ❌ Bad
// @ts-ignore
const unsafe = someComplexObject.deepProperty
```

## Examples to Follow
```typescript
// ✅ Good
interface ApiResponse {
  data: UserData
  status: number
}

const response: ApiResponse = await fetchUserData()
const result = response.data.someProperty  // Type safe

// ✅ Good
function component(props: Omit<ComponentProps, 'profile'>) {
  return <div {...props} />
}

// ✅ Good
interface UserData {
  id: string
  name: string
  email: string
}

function processUser(user: UserData): string {
  return `${user.name} <${user.email}>`
}
```

Remember: Strong typing helps catch bugs early and makes the codebase more maintainable. Never sacrifice type safety for convenience.